### 디스어셈블

입력값과, secretCode 각 요소에 xor 연산한 값을 비교한다.
```c
#include <cstddef>
#include <cstdio>
#include <cstring>

using namespace std;
char secretcode[] = {
    0x60, 0x62, 0x75, 0x67, 0x7A, 0x62, 0x6E, 0x6C, 0x6C, 0x68,
    0x75, 0x75, 0x64, 0x65, 0x5E, 0x75, 0x6E, 0x5E, 0x75, 0x69,
    0x64, 0x5E, 0x6D, 0x64, 0x60, 0x72, 0x75, 0x5E, 0x72, 0x68,
    0x66, 0x6F, 0x68, 0x67, 0x68, 0x62, 0x60, 0x6F, 0x75, 0x5E,
    0x63, 0x68, 0x75, 0x7C
};

int main() {
    char input[72];

    puts("Go ahead, guess the flag: ");
    fgets(input, 0x3f,stdin);

    size_t inputSize = strlen(input);
    for (int i = 0; i < inputSize; i++) {
        input[i] = input[i] ^ 1;
    }

    int compareResult = strcmp(input, secretcode);
    if (compareResult == 0) {
        puts("Correct! It was kinda obvious tbh.");
    } else {
        puts("Wrong. Not sure why you\'d think it\'d be that.");
    }
}

```

### 복호화
```python
secret_code = [0x60, 0x62, 0x75, 0x67, 0x7A, 0x62, 0x6E, 0x6C, 0x6C, 0x68,
               0x75, 0x75, 0x64, 0x65, 0x5E, 0x75, 0x6E, 0x5E, 0x75, 0x69,
               0x64, 0x5E, 0x6D, 0x64, 0x60, 0x72, 0x75, 0x5E, 0x72, 0x68,
               0x66, 0x6F, 0x68, 0x67, 0x68, 0x62, 0x60, 0x6F, 0x75, 0x5E,
               0x63, 0x68, 0x75, 0x7C]


flag = "".join([chr(code ^ 1) for code in secret_code])

print(flag)
```

```
actf{committed_to_the_least_significant_bit}
```